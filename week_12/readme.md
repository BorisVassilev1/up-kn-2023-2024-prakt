# Динамична Памет

### 1) Malloc
Напишете функция, `malloc(size_t size)` която по подадено число заделя точно толкова байта динамична памет и връща указател към тази заделена памет.

### 2) sortCopy
Напишете програма `sortCopy`, която приема масив и указател към връща сортирано копие на този масив без да модифицира подадения масив.

### 3) makeMatrix
Напишете функция `makeMatrix`, която заделя двумерен масив в динамичната памет по подадени размери.

### 4) toString
Напишете функция `toString`, която приема цяло положително число и връща указател към динамично заделен символен низ, в който е записано числото.

### 5) getWord
Напишете функция `char *getWord(char* str, size_t n)`, която приема символен низ и цяло положително число и връща указател към копие на `n`-тата дума в `str` (думи са поднизовете, разделени с интервали)

### 6) resize
Напишете функция `void resize(int *&arr, size_t size, size_t newSize)`, която приема масив от цели числа и текущият му размер и променя размера на масива да е `newSize`.

### 7) reduce
Напишете функция, `void reduce(int *&arr, size_t n, size_t groups)`, която приема масив от цели положителни числа `arr` и размера му `n`. След изпълнението на функцията `arr` има размер `n/groups` и всеки елемент в него е сума на съответните `n` поредни стойности в подадения масив.

### 8) merge
Напишете функция, `merge` която приема два сортирани масива и връща указател към динамично заделен сортиран масив, в който има всички елементи на дадените масиви.

### 8* ) Merge Sort
Нека комбинираме знанията от последните няколко седмици
- Напишете функция `mergeSort`, която приема указател към масив и размерът му и рекурсивно извиква себе си за двете половини на подадения масив. Не забравяйте да поставите дъно на рекурсията (например при размер 1 или 2)
- Нека поставим дъното на рекурсията при размер на масива 2. Това е масив, който можем да сортираме елементарно с проверка за правилна нареденост и размяна на елементите.
- Нека сега за по-големи масиви след двете рекурсивни извиквания използваме функцията `merge`, която написахме по-горе, разчитайки, че двата по-малки масива ще са сортирани.
- `merge` ще ни върне указател към сортиран масив с всички елементи на двата му подадени масива, т.е. всички елементи на масива, подаден като аргумент на `mergeSort`. Остана да копираме съдържанието на вече сортирания масив в първоначалния. (помислете къде и кога трябва да се трие памет)
Честито, написахте един доста сложен алгоритъм. Това е задача за Бонус и струва ЦЕЛИ 10 БОНУС ТОЧКИ.
